---
title: "Transform"
output: github_document
---

<https://dplyr.tidyverse.org/>

## Setup

It's common to start a script using required packages and importing the data.

* Use the package dplyr with `library(dplyr)`, or use the entire tidyverse with

```{r}
library(tidyverse)
```

* Import `gapminder`: A global dataset of life-expectancy through time.

```{r}
gapminder <- read_csv("data/gapminder.csv")
```

* You can preview the `gapminder` dataset with

```{r}
gapminder
```



## Aside: The pipe operator (`%>%`)

Tidyverse functions are designed to work well with the pipe operator (`%>%`). It composes multiple transformations on the same data. Insert it with "Ctrl + Shift + M" on Windows, or "Cmd + Shift + M" on Mac.

The pipe makes multiple transformations easier to understand.

* When you apply a single function to a dataset, the pipe is needless.

```{r}
# `f` of `x`.
f(x)

# Take `x`, then apply `f`.
x %>% 
  f()
```

* When you apply multiple functions to a dataset, the pipe is more readable.

```{r}
# Hard to read: `h` of `g` of `f` of `x`
h(g(f(x)))

# Easy to read: Take `x`, then apply `f`, then apply `g`, then apply `h`.
x %>% 
  f() %>% 
  g() %>% 
  h()
```



## Your turn

This is one other way to view the `gapminder` data.

```{r}
glimpse(gapminder)
```

* Rewrite the code above to produce the same output but this time use the pipe.

```{r}
gapminder %>% glimpse()
```



## The five main verbs

Solve the most common data manipulation challenges with the five main verbs:

* `mutate()` add columns.
* `select()` picks columns.
* `filter()` picks rows.
* `arrange()` changes the ordering of the rows.
* `summarise()` summarises multiple values.

They all input a data frame (spreadsheet) and output a modified data frame.

![](https://i.imgur.com/uICSizl.png)



## `mutate()` adds new columns that are functions of existing columns

```{r}
gapminder %>%
  mutate(gdp = pop * gdpPercap)
```



## `select()` picks columns based on their names

From `gapminder`, you may want only the columns `country`, `year`, and `lifeExp`.

* Take the dataset `gapminder` and then select only the columns you want.

```{r}
gapminder %>% 
  select(country, year, lifeExp)
```

We can instead find all columns in `gapminder` and drop the irrelevant ones.

* Take `gapminder`, and then find the name of all columns with `names()`.

```{r}
gapminder %>% 
  names()
```

* Take `gapminder`, and then drop each irrelevant column as `-column`.

```{r}
gapminder %>% 
  select(-continent, -pop, -gdpPercap)
```



## `filter()` picks rows based on their values

From `gapminder`, say you want to pick only rows where `year` is 2002.

* Take `gapminder`, then `filter()` with the logical expression `year == 2002`.

```{r}
gapminder %>% 
  filter(year == 2002)
```



You can filter with multiple logical expressions separated by comma "," or and "&". Consider these logical expressions: `==`, `!=`, `<`, `>`, `<=`, `=>`.

* Take `gapminder`, and then `filter()` with two logical expressions to find the life expectancy of Afghanistan in 1962.

```{r}
gapminder %>% 
  filter(country == "Afghanistan" & year == 1962)
```



One way to understand filter is to visualize the logical expressions it uses.

* Predict what this pipe returns; then run it. Explain to yourself this result.

```{r}
gapminder %>%
  # Drop irrelevant columns
  select(-continent, -pop, -gdpPercap) %>%
  # Add column to see the result of a logical expression I want to use
  mutate(to_pick = country == "Afghanistan" & year == 1962) %>%
  # The logical expression looks good, so I use it
  filter(to_pick)
```

## `arrange()` changes the ordering of the rows

Where and when was the lowest life expectancy?

* Take `gapminder`, then arrange it by (ascending) `lifeExp`.

```{r}
gapminder %>%
  arrange(lifeExp) %>% 
  select(country, year, lifeExp)
```

Where and when was the highest life expectancy?

* Take `gapminder`, then arrange it by descending `lifeExp`.

```{r}
gapminder %>%
  arrange(desc(lifeExp)) %>% 
  select(country, year, lifeExp)
```



## `summarise()` reduces multiple values to a single summary.

```{r}
gapminder %>% 
  summarise(mean_lifeExp = mean(lifeExp))
```

This is not terribly useful; `summarize()` is best combined with `group_by()`.



## group_by() perform any operation "by group"

Improve the summary you just did:

* Now calculate life expectancy for each continent.

```{r}
gapminder %>%
  group_by(continent) %>% 
  summarise(mean_lifeExp = mean(lifeExp))
```



Improve the summary you just did:

* Now also add the minimum and maximum life expectancy for each continent.

```{r}
gapminder %>%
  group_by(continent) %>% 
  summarise(
    mean_lifeExp = mean(lifeExp),
    min_lifeExp = min(lifeExp),
    max_lifeExp = max(lifeExp)
  )
```



## Putting it together

In the previous millenia, was the life expectancy in each continent explained by its mean GDP?

```{r}
gapminder %>% 
  group_by(continent) %>%
  mutate(gdp = pop * gdpPercap) %>%
  filter(year < 2000) %>% 
  summarize(mean_gdp = mean(gdp), mean_lifeExp = mean(lifeExp)) %>% 
  arrange(desc(mean_lifeExp), desc(mean_gdp))
```

## Joining datasets19622007, co2, by = "country")

## explore
rj %>% dim() # 12
rj %>% summary()
rj %>% View() 
```

## Takeaways

* The filter() function subsets a dataframe by rows.

* The select() function subsets a dataframe by columns.

* The mutate function creates new columns in a dataframe.

* The group_by() function creates groups of unique column values.

* This grouping information is used by summarize() to make new columns that 
define aggregate values across groupings.

* The then pipe operator %>% allows you to chain successive operations without 
needing to define intermediary variables for creating the most parsimonious, 
easily read analysis.1962196219621962196219621962