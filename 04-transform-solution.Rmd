---
title: "Transform"
output: github_document
---

<https://dplyr.tidyverse.org/>

## Setup

It's common to start a script using required packages and importing the data.

* Use the package dplyr with `library(dplyr)`, or use the entire tidyverse with

```{r}
library(tidyverse)
```

* Import `gapminder`: A global dataset of life-expectancy through time.

```{r}
gapminder <- read_csv("data/gapminder.csv")
```

* You can preview the `gapminder` dataset with

```{r}
gapminder
```



## Aside: The pipe operator (`%>%`)

Tidyverse functions are designed to work well with the pipe operator (`%>%`). It composes multiple transformations on the same data. Insert it with "Ctrl + Shift + M" on Windows, or "Cmd + Shift + M" on Mac.

The pipe makes multiple transformations easier to understand.

* When you apply a single function to a dataset, the pipe is needless.

```{r}
# `f` of `x`.
f(x)

# Take `x`, then apply `f`.
x %>% 
  f()
```

* When you apply multiple functions to a dataset, the pipe is more readable.

```{r}
# Hard to read: `h` of `g` of `f` of `x`
h(g(f(x)))

# Easy to read: Take `x`, then apply `f`, then apply `g`, then apply `h`.
x %>% 
  f() %>% 
  g() %>% 
  h()
```



## Your turn

This is one other way to view the `gapminder` data.

```{r}
glimpse(gapminder)
```

* Rewrite the code above to produce the same output but this time use the pipe.

```{r}
gapminder %>% glimpse()
```



## The five main verbs

Solve the most common data manipulation challenges with the five main verbs:

* `mutate()` add columns.
* `select()` picks columns.
* `filter()` picks rows.
* `summarise()` reduces multiple values down to a single summary.
* `arrange()` changes the ordering of the rows.

They all input a data frame (spreadsheet) and output a modified data frame.

![](https://i.imgur.com/uICSizl.png)



## `mutate()` adds new columns that are functions of existing columns

```{r}
gapminder %>%
  mutate(gdp = pop * gdpPercap)
```



## `select()` picks columns based on their names

From `gapminder`, you may want only the columns `country`, `year`, and `lifeExp`.

* Take the dataset `gapminder` and then select only the columns you want.

```{r}
gapminder %>% 
  select(country, year, lifeExp)
```

We can instead find all columns in `gapminder` and drop the irrelevant ones.

* Take `gapminder`, and then find the name of all columns with `names()`.

```{r}
gapminder %>% 
  names()
```

* Take `gapminder`, and then drop each irrelevant column as `-column`.

```{r}
gapminder %>% 
  select(-continent, -pop, -gdpPercap)
```



## `filter()` picks rows based on their values

From `gapminder`, say you want to pick only rows where `year` is 2002.

* Take `gapminder`, then `filter()` with the logical expression `year == 2002`.

```{r}
gapminder %>% 
  filter(year == 2002)
```



You can filter with multiple logical expressions separated by comma "," or and "&". Consider these logical expressions: `==`, `!=`, `<`, `>`, `<=`, `=>`.

* Take `gapminder`, and then `filter()` with two logical expressions to find the life expectancy of Afghanistan in 1962.

```{r}
gapminder %>% 
  filter(country == "Afghanistan" & year == 1962)
```



One way to understand filter is to visualize the logical expressions it uses.

* Predict what this pipe returns; then run it. Explain to yourself this result.

```{r}
gapminder %>%
  # Drop irrelevant columns
  select(-continent, -pop, -gdpPercap) %>%
  # Add column to see the result of a logical expression I want to use
  mutate(to_pick = country == "Afghanistan" & year == 1962) %>%
  # The logical expression looks good, so I use it
  filter(to_pick)
```




## group_by() makes groups out of variables, that you can summarize()

How would we calculate gdpPercap at the country-level for all countries?

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap, max_gdp = max(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```

We now have a `max_gdp` column that shows the maximum GDP, by country, of every 
country in the dataset. But if you look closely, the values are repeated:

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap, max_gdp = max(gdp)) %>%
  ungroup() %>% # if you use group_by, also use ungroup() to save heartache later
  tail(30)
```

It is showing the maximum gdp for each country, but this value is indepdendent 
of year, so it shows the same value for every year. What if we want to collapse 
the data to only show the information we are interested in? 

This is where `summarise()` comes in. `group_by()` and `summarise()` are very 
commonly used together to perform tasks on groups of data, and distill the 
output: 

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap) %>%
  summarize(max_gdp = max(gdp)) %>%
  ungroup()
```

## arrange() arranges rows 

The gapminder dataset is organized in alphabetical order by country, but what if 
we wanted to arrange our new max_gdp dataset by decreasing max_gdp? 

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap) %>%
  summarize(max_gdp = max(gdp)) %>%
  ungroup() %>%
  arrange(max_gdp)
```

### Challenge 

* Arrange your data frame in descending order (opposite of what we’ve done). 
Expect that this is possible: see ?arrange for help
* Find the maximum life expectancy for countries in Asia. What is the earliest 
year you encounter? The latest? 
* Hint: you can use either base::max or dplyr::arrange()…

```{r}

```

## Putting it together

Before we get to the next module, I wanted to tease a full pipeline from import 
to summary: 

```{r}
# install libraries if necessary
# install.packages('tidyverse')

# load libraries
library(tidyverse)

# read in data
gapminder <- readr::read_csv('https://raw.githubusercontent.com/carpentries-incubator/open-science-with-r/gh-pages/data/gapminder.csv') 

## summarize
gap_max_gdp <- gapminder %>% 
  dplyr::select(-continent, -lifeExp) %>% # or select(country, year, pop, gdpPercap)
  dplyr::group_by(country) %>%
  dplyr::mutate(gdp = pop * gdpPercap) %>%
  dplyr::summarize(max_gdp = max(gdp)) %>%
  dplyr::ungroup() 
```

## Joining datasets19622007, co2, by = "country")

## explore
rj %>% dim() # 12
rj %>% summary()
rj %>% View() 
```

## Takeaways

* The filter() function subsets a dataframe by rows.

* The select() function subsets a dataframe by columns.

* The mutate function creates new columns in a dataframe.

* The group_by() function creates groups of unique column values.

* This grouping information is used by summarize() to make new columns that 
define aggregate values across groupings.

* The then pipe operator %>% allows you to chain successive operations without 
needing to define intermediary variables for creating the most parsimonious, 
easily read analysis.1962196219621962196219621962