---
title: "Transform"
output: github_document
---

<https://dplyr.tidyverse.org/>

## Setup

It's common to start a script using required packages and importing the data.

* Use the package dplyr with `library(dplyr)`, or use the entire tidyverse with

```{r}
library(tidyverse)
```

* Import `gapminder`: A global dataset of life-expectancy through time.

```{r}
gapminder <- read_csv("data/gapminder.csv")
```

* You can preview the `gapminder` dataset with

```{r}
gapminder
```



## Aside: The pipe operator (`%>%`)

Tidyverse functions are designed to work well with the pipe operator (`%>%`). It composes multiple transformations on the same data. Insert it with "Ctrl + Shift + M" on Windows, or "Cmd + Shift + M" on Mac.

The pipe makes multiple transformations easier to understand.

* When you apply a single function to a dataset, the pipe is needless.

```{r}
# `f` of `x`.
f(x)

# Take `x`, then apply `f`.
x %>% 
  f()
```

* When you apply multiple functions to a dataset, the pipe is more readable.

```{r}
# Hard to read: `h` of `g` of `f` of `x`
h(g(f(x)))

# Easy to read: Take `x`, then apply `f`, then apply `g`, then apply `h`.
x %>% 
  f() %>% 
  g() %>% 
  h()
```



## Your turn

This is one other way to view the `gapminder` data.

```{r}
glimpse(gapminder)
```

* Rewrite the code above to produce the same output but this time use the pipe.

```{r}
gapminder %>% glimpse()
```



## The five main verbs

Solve the most common data manipulation challenges with the five main verbs:

* `mutate()`
* `select()`
* `filter()` picks cases based on their values.
* `summarise()` reduces multiple values down to a single summary.
* `arrange()` changes the ordering of the rows.

They all input a data frame (spreadsheet) and output a modified data frame.

![](https://i.imgur.com/uICSizl.png)



## `mutate()` adds new columns that are functions of existing columns

```{r}
gapminder %>%
  mutate(gdp = pop * gdpPercap)
```



## `select()` picks columns based on their names

From `gapminder`, you may want only the columns `country`, `year`, and `lifeExp`.

* Take the dataset `gapminder` and then select only the columns you want.

```{r}
gapminder %>% 
  select(country, year, lifeExp)
```

We can instead find all columns in `gapminder` and drop the irrelevant ones.

* Take `gapminder`, and then find the name of all columns with `names()`.

```{r}
gapminder %>% 
  names()
```

* Take `gapminder`, and then drop each irrelevant column as `-column`.

```{r}
gapminder %>% 
  select(-continent, -pop, -gdpPercap)
```



## `filter()` picks rows based on their values.

From `gapminder`, say you want to pick only rows where `year` is 2002.

* Take `gapminder`, then `filter()` with the logical expression `year == 2002`.

```{r}
gapminder %>% 
  filter(year == 2002)
```



You can filter with multiple logical expressions separated by comma ",". Consider these logical expressions: `==`, `!=`, `<`, `>`, `<=`, `=>`.

* Take `gapminder`, and then `filter()` with two logical expressions to find the life expectancy of Argentina in 2007.

```{r}
gapminder %>% 
  filter(country == "Argentina", year == 2007)
```











## Leftovers

```{r}
# instead of this...
gap_cambodia  <- filter(gapminder, country == "Cambodia")
gap_cambodia2 <- select(gap_cambodia, -continent, -lifeExp)

# we can do this
gap_cambodia  <- gapminder %>% filter(country == "Cambodia")
gap_cambodia2 <- gap_cambodia %>% select(-continent, -lifeExp)

# we can do this
gap_cambodia  <- gapminder %>% 
  filter(country == "Cambodia") %>% 
  select(-continent, -lifeExp)
```




## Using filter() and select() together
Let's say we wanted to filter for "Cambodia" and remove the continent and 
lifeExp variables. We could do this in two steps: 

```{r}
gap_cambodia  <- filter(gapminder, country == "Cambodia")
gap_cambodia2 <- select(gap_cambodia, -continent, -lifeExp)
```

But this seems like a cumbersome process, especially for longer data pipelines.
Luckily, R has a more elegant solution. 


## Exercise

Using the verbs we have learnt so far, and the pipe operator, find the maximum 
gdpPercap of Egypt and the maximum gdpPercap of Vietnam. Create a new column 
with mutate(). Hint: use max()

```{r}
# Egypt:
gapminder %>%
filter(___) %>%
mutate(___) %>%
mutate(___)

# Vietnam:
gapminder %>%
filter(___) %>%
mutate(___)
```

This is a little awkward. We have to copy and paste the exact same code twice, 
just to calculate the same thing for two different countries. 




## group_by() makes groups out of variables, that you can summarize()

How would we calculate gdpPercap at the country-level for all countries?

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap, max_gdp = max(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```

We now have a `max_gdp` column that shows the maximum GDP, by country, of every 
country in the dataset. But if you look closely, the values are repeated:

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap, max_gdp = max(gdp)) %>%
  ungroup() %>% # if you use group_by, also use ungroup() to save heartache later
  tail(30)
```

It is showing the maximum gdp for each country, but this value is indepdendent 
of year, so it shows the same value for every year. What if we want to collapse 
the data to only show the information we are interested in? 

This is where `summarise()` comes in. `group_by()` and `summarise()` are very 
commonly used together to perform tasks on groups of data, and distill the 
output: 

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap) %>%
  summarize(max_gdp = max(gdp)) %>%
  ungroup()
```

## arrange() arranges rows 

The gapminder dataset is organized in alphabetical order by country, but what if 
we wanted to arrange our new max_gdp dataset by decreasing max_gdp? 

```{r}
gapminder %>%
  group_by(country) %>%
  mutate(gdp = pop * gdpPercap) %>%
  summarize(max_gdp = max(gdp)) %>%
  ungroup() %>%
  arrange(max_gdp)
```

### Challenge 

* Arrange your data frame in descending order (opposite of what we’ve done). 
Expect that this is possible: see ?arrange for help
* Find the maximum life expectancy for countries in Asia. What is the earliest 
year you encounter? The latest? 
* Hint: you can use either base::max or dplyr::arrange()…

```{r}

```

## Putting it together

Before we get to the next module, I wanted to tease a full pipeline from import 
to summary: 

```{r}
# install libraries if necessary
# install.packages('tidyverse')

# load libraries
library(tidyverse)

# read in data
gapminder <- readr::read_csv('https://raw.githubusercontent.com/carpentries-incubator/open-science-with-r/gh-pages/data/gapminder.csv') 

## summarize
gap_max_gdp <- gapminder %>% 
  dplyr::select(-continent, -lifeExp) %>% # or select(country, year, pop, gdpPercap)
  dplyr::group_by(country) %>%
  dplyr::mutate(gdp = pop * gdpPercap) %>%
  dplyr::summarize(max_gdp = max(gdp)) %>%
  dplyr::ungroup() 
```

## Joining datasets

So far, we have only been working with one dataset. Before moving on, I want to 
talk to you briefly about joining two different datasets by a common variable.
T
here are different ways to do this. Suppose we have two datasets a and b, that 
we want to join together by the variable year.
We could: 
* Join all matching rows from b to a
* Join all matching rows from a to b
* Join both datasets, retaining only rows that are present in both a an b
* Join both datasets, retaining all rows and values in both datasets

To get a better idea of what I mean by this, check out this diagram: 
https://i.imgur.com/fV4St9d.png

This idea of "relational data" can take a second to click, so for now, I leave 
you to explore the following example. See if you can see for yourself what these 
different types of matching and joining can produce: 

```{r}
## read in the data.
co2 <- read_csv("https://raw.githubusercontent.com/carpentries-incubator/open-science-with-r/gh-pages/data/co2.csv")

## explore
co2 %>% head()
co2 %>% dim() # 12

## create new variable that is only 2007 data
gap_2007 <- gapminder %>%
  filter(year == 2007) 
gap_2007 %>% dim() # 142  

## left_join gap_2007 to co2
lj <- left_join(gap_2007, co2, by = "country")

## explore
lj %>% dim() #142
lj %>% summary() # lots of NAs in the co2_2017 columm
lj %>% View() 

## right_join gap_2007 and co2
rj <- right_join(gap_2007, co2, by = "country")

## explore
rj %>% dim() # 12
rj %>% summary()
rj %>% View() 
```

## Takeaways

* The filter() function subsets a dataframe by rows.

* The select() function subsets a dataframe by columns.

* The mutate function creates new columns in a dataframe.

* The group_by() function creates groups of unique column values.

* This grouping information is used by summarize() to make new columns that 
define aggregate values across groupings.

* The then pipe operator %>% allows you to chain successive operations without 
needing to define intermediary variables for creating the most parsimonious, 
easily read analysis.