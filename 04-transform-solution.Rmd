---
title: "Transform"
output: github_document
---

<https://github.com/maurolepore/open-science-with-r>

## Setup

It's common to start a script using required packages and importing the data. Use the dplyr package with `library(dplyr)`, or all tidyverse packages with

```{r}
library(tidyverse)
```

Import `gapminder`: A global dataset of life-expectancy through time.

```{r}
gapminder <- read_csv("data/gapminder.csv")
```

Preview the `gapminder` dataset with

```{r}
gapminder
```



## The pipe operator (`%>%`)

Tidyverse functions work well with the pipe operator (`%>%`). The pipe makes it easier to understand multiple transformations on the same data.

When you apply a single function to a dataset, the pipe is needless.

```{r eval=FALSE}
# `f` of `x`.
f(x)

# Take `x`, then apply `f`.
x %>% 
  f()
```

When you apply multiple functions to a dataset, the pipe is more readable.

```{r, eval=FALSE}
# Hard to read: `h` of `g` of `f` of `x`
h(g(f(x)))

# Easy to read: Take `x`, then apply `f`, then apply `g`, then apply `h`.
x %>% 
  f() %>% 
  g() %>% 
  h()
```

## Your turn

This is one other way to view the `gapminder` data.

```{r}
glimpse(gapminder)
```

* Rewrite the code above to produce the same output but this time use the pipe. 
* Insert the pipe with *Ctrl+Shift+M* on Windows, or *Cmd+Shift+M* on Mac.

```{r}
gapminder %>% glimpse()
```



## The five main verzs

Solve the most common data manipulation challenges with the five main verbs:

* `mutate()` add columns.
* `select()` picks columns.
* `filter()` picks rows.
* `arrange()` changes the ordering of the rows.
* `summarise()` summarizes multiple values.

They all input a data frame (spreadsheet) and output a modified data frame.



## `mutate()` adds new columns that are a function of existing columns

* Take `gapminder` and then add a new column `gdp` from `pop` times `gdpPercap`.

```{r}
gapminder %>%
  mutate(gdp = pop * gdpPercap)
```



## `select()` picks columns based on their names

* Take `gapminder` and then select only `country`, `year`, and `lifeExp`.

```{r}
gapminder %>% 
  select(country, year, lifeExp)
```



We can instead find all columns in a dataset and drop the irrelevant ones.

* Take `gapminder`, and then find the name of all columns with `names()`.

```{r}
gapminder %>% 
  names()
```

* Now take `gapminder`, and then drop each irrelevant column with `-column`.

```{r}
gapminder %>% 
  select(-continent, -pop, -gdpPercap)
```



## `filter()` pick rows based on their values

* Take `gapminder`, then `filter()` with the logical expression `year == 2002`.

```{r}
gapminder %>% 
  filter(year == 2002)
```


`filter()` can take multiple logical expressions separated by "," or "&".

* Take `gapminder`, and then `filter()` with two logical expressions to find the life expectancy of Afghanistan in 1962.

* Remember the logical operators: `==`, `!=`, `<`, `>`, `<=`, `=>`.

```{r}
gapminder %>% 
  filter(country == "Afghanistan" & year == 1962)
```



One way to understand filter is to visualize the logical expressions it uses.

* Predict what this code returns; then run it. Explain to yourself this result.

```{r}
gapminder %>%
  # Drop irrelevant columns
  select(-continent, -pop, -gdpPercap) %>%
  # Add column to see the result of a logical expression I want to use
  mutate(to_pick = country == "Afghanistan" & year == 1962) %>%
  # The logical expression looks good, so I use it
  filter(to_pick)
```



## `arrange()` changes the ordering of the rows

Where and when was the lowest life expectancy?

* Take `gapminder`, then arrange it by (ascending) `lifeExp`.

```{r}
gapminder %>%
  arrange(lifeExp) %>% 
  select(country, year, lifeExp)
```

Where and when was the highest life expectancy?

* Take `gapminder`, then arrange it by descending `lifeExp` (see `?desc()`).

```{r}
gapminder %>%
  arrange(desc(lifeExp)) %>% 
  select(country, year, lifeExp)
```



## `summarize()` reduces multiple values to a single summary.

* Take `gapminder` and then summarize it by computing the mean life expectancy.

```{r}
gapminder %>% 
  summarize(mean_lifeExp = mean(lifeExp))
```

This is not terribly useful; `summarize()` is best combined with `group_by()`.



## group_by() perform any operation "by group"

Improve the summary you just did:

* Now calculate life expectancy for each continent.

```{r}
gapminder %>%
  group_by(continent) %>% 
  summarize(mean_lifeExp = mean(lifeExp))
```



## Putting it together

Compare continents before 2000: Did life expectancy increase with total `gdp`?

```{r}
gapminder %>% 
  group_by(continent) %>%
  mutate(gdp = pop * gdpPercap) %>%
  filter(year < 2000) %>% 
  summarize(mean_gdp = mean(gdp), mean_lifeExp = mean(lifeExp)) %>% 
  arrange(desc(mean_lifeExp), desc(mean_gdp))
```

## Takeaways

* The pipe makes it easier to read multiple transformations on the same data.

* You can solve most data manipulation challenges with five dplyr verbs:

  * `mutate()` adds new variables that are functions of existing variables
  * `select()` picks variables based on their names.
  * `filter()` picks cases based on their values.
  * `summarise()` reduces multiple values down to a single summary.
  * `arrange()` changes the ordering of the rows.
  
* Combine the main verbs with `group_by()` to perform any operation "by group".
